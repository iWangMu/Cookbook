## 数组类型

> JS数组在TS中分成两种类型，即`数组(Array)`和`元组(Tuple)`。

### Array

> 所有Item的**数据类型必须相同**，成员数量不固定，可以是零或无限数量成员。

#### 数组声明

```TS
// 数组Item的类型是`number`
let arr1: number[] = [0, 2, 4, 6, 8];
// 数组Item的类型是`number`或`string`
let arr2: (number | string)[] = ['a', 1, 'b', 3, 5];

// 数组泛型写法声明：
// 数组Item的类型是`number`
let arr3: Array<number> = [1, 3, 5, 7, 9];
// 数组Item的类型是`number`或`string`
let arr4: Array<number | string> = ['a', 'b', 'c', 42];
```

#### 类型推断

如果数组变量没有声明类型，TS会根据初始值推断数组的类型：
```ts
let arr1 = [];             // any[]
let arr2 = [42];           // number[]
let arr3 = ['hello'];      // string[]
let arr4 = [42, 'hello'];  // (number | string)[]
```

#### 只读数组

- `readonly`关键字声明只读数组，增加、删除、修改数组成员都会报错。
- `readonly`**不能**与数组泛型写法一起使用，泛型只读数组：`ReadonlyArray<T>`和`Readonly<T[]>`
- `as const`(**const断言**)也可以声明只读数组。

```ts
// `readonly`
const arr1: readonly number[] = [1, 3, 5, 7, 9];
// `number[]`是`readonly number[]`的子类型，因为它比只读数组多了`pop()`、`push()`等方法
const arr2: number[] = [2, 4, 42];
const arr3: readonly number[] = arr2;
// 泛型声明数组
const arr4: ReadonlyArray<number> = [2, 4, 42];
const arr5: Readonly<number[]> = [2, 4, 42];
// `as const`断言
const arr6 = [2, 4];          // number[]
const arr7 = [2, 4] as const; // readonly [2, 4]
```

#### 多维数组

TS使用`T[][]`格式声明二维数组，`T`是底层数组成员的类型：
```ts
const mdArray: number[][] = [
  [1, 3, 5],
  [2, 4, 6],
];
```



### Tuple
它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。
使用元组时，必须明确给出类型声明（上例的[number]），不能省略，否则 TypeScript 会把一个值自动推断为数组。
元组成员的类型可以添加问号后缀（?），表示该成员是可选的。


### 数组Item的类型
TypeScript 允许使用方括号读取数组成员的类型。

type Names = string[];
type Name = Names[0]; // string
上面示例中，类型Names是字符串数组，那么Names[0]返回的类型就是string。

由于数组成员的索引类型都是number，所以读取成员类型也可以写成下面这样。

type Names = string[];
type Name = Names[number]; // string
上面示例中，Names[number]表示数组Names所有数值索引的成员类型，所以返回string。



